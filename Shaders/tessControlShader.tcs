// first step of tesselation shader
// tesselation control shader add/deletes control points and determines the tesselatation level
// patch has three control points here (three vertices for each triangle)


#version 450 core
layout (vertices =3) out;


// vectors stored as arrays - each patch has three vertices, each with an xyz pos and xyz norm value 
//posVS = position from Vertex Shader, posTC = position from this Tesselation Control shader

uniform vec3 viewPos ;

in vec3 posVS[] ;
in vec2 texCorrdsVS[];

out vec3 posTC[] ;
out vec2 texCorrdsTC[];




void main()
{
	// tesselation level; we wil find this automatically later but for now hardcoded value
	int tessLevel = 1;
   
	float dist1 = distance(viewPos,posVS[0]);
	float dist2 = distance(viewPos,posVS[1]);
	float dist3 = distance(viewPos,posVS[2]);
	
	float avgDist = (dist1 + dist2 + dist3) / 3;
	
	if(avgDist < 250) tessLevel = 1;
	if(avgDist < 100) tessLevel = 1;


   // gpu can calculate each control point in parallel
   // tesselation level same for entire patch so only need to set it once (for the first control point)
   // gl_invocation called for each control point
   if (gl_InvocationID==0)
   {
		   // Calculate the tessellation levels
          gl_TessLevelOuter[0] = tessLevel ; 
          gl_TessLevelOuter[1] = tessLevel ; 
          gl_TessLevelOuter[2] = tessLevel ;
          gl_TessLevelInner[0] = tessLevel ; 

   }

   // pass through position and normal information
   posTC[gl_InvocationID]  = posVS[gl_InvocationID] ;
   texCorrdsTC[gl_InvocationID] = texCorrdsVS[gl_InvocationID];
}
